/**
 * Web polyfill for expo/fetch with Vibecode proxy support
 *
 * This wraps the global fetch to add proxy functionality for specified domains.
 * Similar to the iOS native implementation in ExpoURLSessionTask.swift.
 *
 * Auto-configures on import - no manual setup required.
 */
// Symbol to mark that we've already initialized (prevents double-init)
const VIBECODE_FETCH_INSTALLED = Symbol.for('vibecode.fetch.installed');
// Check if already initialized to prevent double-wrapping
const alreadyInstalled = typeof globalThis !== 'undefined' &&
    globalThis[VIBECODE_FETCH_INSTALLED];
// Constants
const PROXY_HOST = 'proxy.vibecodeapp.com';
const DOMAINS_API_URL = 'https://proxy.vibecodeapp.com/v1/domains';
// Default list of proxied domains
const DEFAULT_PROXIED_DOMAINS = [
    'openrouter.ai',
    'api.openai.com',
    'api.anthropic.com',
    'api.x.ai',
    'bedrock-runtime.us-west-2.amazonaws.com',
    'generativelanguage.googleapis.com',
    'api.elevenlabs.io',
    'api.groq.com',
    'api.openweathermap.org',
    'api.themoviedb.org',
    'api.ideogram.ai',
    'api.resend.com',
    'www.alphavantage.co',
];
// Store the original fetch before we do anything (only if not already installed)
const originalFetch = alreadyInstalled
    ? globalThis.fetch
    : globalThis.fetch;
// Proxy configuration
const proxiedDomains = new Set(DEFAULT_PROXIED_DOMAINS);
/**
 * Get the project ID from environment variables.
 * Checks multiple common env var naming conventions.
 */
function getProjectId() {
    if (typeof process !== 'undefined' && process.env) {
        return (process.env.EXPO_PUBLIC_VIBECODE_PROJECT_ID ||
            process.env.VIBECODE_PROJECT_ID ||
            process.env.VITE_VIBECODE_PROJECT_ID ||
            process.env.NEXT_PUBLIC_VIBECODE_PROJECT_ID);
    }
    return undefined;
}
/**
 * Check if a host should be proxied.
 */
function shouldProxyHost(host) {
    for (const domain of proxiedDomains) {
        if (host === domain || host.endsWith(`.${domain}`)) {
            return true;
        }
    }
    return false;
}
/**
 * Apply proxy transformation to a URL if it matches proxied domains.
 * Returns an object with the (possibly modified) URL and whether it was proxied.
 */
function applyProxyToUrl(url) {
    if (!shouldProxyHost(url.hostname)) {
        return { url, wasProxied: false };
    }
    const proxiedUrl = new URL(url.toString());
    proxiedUrl.hostname = `${url.hostname}.${PROXY_HOST}`;
    return { url: proxiedUrl, wasProxied: true };
}
/**
 * Proxied fetch implementation.
 * Wraps the global fetch to add proxy support for specified domains.
 */
export async function fetch(input, init) {
    const projectId = getProjectId();
    // Parse the URL from the input
    let url;
    let requestInit = init ? { ...init } : {};
    if (input instanceof Request) {
        url = new URL(input.url);
        // Merge headers from Request and init
        const requestHeaders = new Headers(input.headers);
        if (init?.headers) {
            const initHeaders = new Headers(init.headers);
            initHeaders.forEach((value, key) => {
                requestHeaders.set(key, value);
            });
        }
        requestInit = {
            method: init?.method ?? input.method,
            headers: requestHeaders,
            body: init?.body ?? input.body,
            mode: init?.mode ?? input.mode,
            credentials: init?.credentials ?? input.credentials,
            cache: init?.cache ?? input.cache,
            redirect: init?.redirect ?? input.redirect,
            referrer: init?.referrer ?? input.referrer,
            referrerPolicy: init?.referrerPolicy ?? input.referrerPolicy,
            integrity: init?.integrity ?? input.integrity,
            keepalive: init?.keepalive ?? input.keepalive,
            signal: init?.signal ?? input.signal,
        };
    }
    else if (input instanceof URL) {
        url = input;
    }
    else {
        url = new URL(input, globalThis.location?.origin);
    }
    // Apply proxy transformation
    const { url: proxiedUrl, wasProxied } = applyProxyToUrl(url);
    // Add proxy header if the URL was proxied and we have a project ID
    if (wasProxied && projectId) {
        const headers = new Headers(requestInit.headers);
        headers.set('X-Vibecode-Project', projectId);
        requestInit.headers = headers;
    }
    // Make the request with the (possibly) proxied URL
    return originalFetch(proxiedUrl.toString(), requestInit);
}
/**
 * Fetch additional domains from the API and add them to the proxy list.
 * This runs in the background and doesn't block initialization.
 */
async function fetchAndAddDomains() {
    try {
        const response = await originalFetch(DOMAINS_API_URL);
        if (response.ok) {
            const data = await response.json();
            if (Array.isArray(data)) {
                for (const domain of data) {
                    if (typeof domain === 'string') {
                        proxiedDomains.add(domain);
                    }
                }
            }
            else if (data.domains && Array.isArray(data.domains)) {
                for (const domain of data.domains) {
                    if (typeof domain === 'string') {
                        proxiedDomains.add(domain);
                    }
                }
            }
        }
    }
    catch {
        // Silently fail - we have default domains as fallback
    }
}
/**
 * Install the proxied fetch as the global fetch.
 */
function installGlobalFetch() {
    if (typeof globalThis !== 'undefined' && !alreadyInstalled) {
        ;
        globalThis.fetch = fetch;
        globalThis[VIBECODE_FETCH_INSTALLED] = true;
    }
}
// Auto-initialize on import (skips if already done)
if (!alreadyInstalled) {
    installGlobalFetch();
    fetchAndAddDomains();
}
//# sourceMappingURL=fetch.web.js.map