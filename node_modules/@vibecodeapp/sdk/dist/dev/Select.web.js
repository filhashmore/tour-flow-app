/**
 * Element Selection Module (Web)
 *
 * Enables visual element selection within the iframe. When the parent sends
 * 'vibecode:select:start', this component activates selection mode:
 *
 * - Hovering an element highlights it (blue outline)
 * - Clicking an element locks it as selected (green outline) and notifies parent
 * - Cmd/Ctrl + click for multi-select
 * - Parent confirms via 'vibecode:select:confirm' to finalize
 * - Parent can cancel via 'vibecode:select:cancel'
 *
 * Only one selection session can be active at a time.
 * All event listeners use capture phase to intercept before the app.
 */
import { useEffect } from 'react';
const HOVERED_ATTR = 'data-vibecode-hovered';
const SELECTED_ATTR = 'data-vibecode-selected';
const CHILD_ATTR = 'data-vibecode-child';
/** Cleanup function for the active selection session */
let activeSession = null;
/** Confirm handler for the active session */
let confirmHandler = null;
/**
 * Extract React fiber info if available.
 */
function getReactInfo(el) {
    try {
        const fiberKey = Object.keys(el).find((key) => key.startsWith('__reactFiber') || key.startsWith('__reactInternalInstance'));
        if (!fiberKey)
            return null;
        const fiber = el[fiberKey];
        if (!fiber)
            return null;
        let componentName = null;
        const fiberType = fiber.type;
        if (fiberType && typeof fiberType === 'object') {
            componentName = fiberType.displayName || fiberType.name || null;
        }
        else if (typeof fiberType === 'string') {
            componentName = fiberType;
        }
        const source = fiber._debugSource;
        // Map to sourceInfo format to align with webapp
        if (source?.fileName) {
            return {
                fileName: source.fileName,
                lineNumber: source.lineNumber || null,
                columnNumber: source.columnNumber || null,
                displayName: el.tagName.toLowerCase(),
                componentName,
            };
        }
        return null;
    }
    catch {
        return null;
    }
}
/**
 * Extract inline styles from element.
 */
function getInlineStyles(el) {
    const htmlEl = el;
    const result = {};
    if (htmlEl.style) {
        for (let i = 0; i < htmlEl.style.length; i++) {
            const prop = htmlEl.style[i];
            result[prop] = htmlEl.style.getPropertyValue(prop);
        }
    }
    return result;
}
/**
 * Get classes as array from element.
 */
function getClasses(el) {
    const className = el.className && typeof el.className === 'string' ? el.className : '';
    return className.trim() ? className.trim().split(/\s+/) : [];
}
/**
 * Get ancestor hierarchy up to maxDepth levels.
 */
function getAncestors(el, maxDepth = 5) {
    const ancestors = [];
    let current = el.parentElement;
    let depth = 0;
    while (current && current !== document.documentElement && depth < maxDepth) {
        ancestors.push({
            tagName: current.tagName.toLowerCase(),
            id: current.id || null,
            classes: getClasses(current),
        });
        current = current.parentElement;
        depth++;
    }
    return ancestors;
}
/**
 * Get direct children summary.
 */
function getChildren(el, maxCount = 10) {
    return Array.from(el.children)
        .slice(0, maxCount)
        .map((child) => ({
        tagName: child.tagName.toLowerCase(),
        id: child.id || null,
        classes: getClasses(child),
    }));
}
/**
 * Extract comprehensive metadata from an element.
 */
function getElementMetadata(el) {
    const rect = el.getBoundingClientRect();
    const htmlEl = el;
    const inputEl = el;
    const anchorEl = el;
    const imgEl = el;
    // Attributes (excluding class - use classes array instead)
    const attributes = {};
    for (let i = 0; i < el.attributes.length; i++) {
        const attr = el.attributes[i];
        if (attr.name !== 'class') {
            attributes[attr.name] = attr.value;
        }
    }
    // Computed styles
    const styles = getComputedStyle(el);
    const computedStyles = {
        color: styles.color,
        fontSize: styles.fontSize,
        fontWeight: styles.fontWeight,
        fontFamily: styles.fontFamily,
        lineHeight: styles.lineHeight,
        textAlign: styles.textAlign,
        backgroundColor: styles.backgroundColor,
        display: styles.display,
        position: styles.position,
        width: styles.width,
        height: styles.height,
        padding: styles.padding,
        margin: styles.margin,
        border: styles.border,
        borderRadius: styles.borderRadius,
        opacity: styles.opacity,
        zIndex: styles.zIndex,
    };
    // Form element info
    const isFormElement = ['INPUT', 'TEXTAREA', 'SELECT', 'BUTTON'].includes(el.tagName);
    const inputInfo = isFormElement
        ? {
            type: inputEl.type || null,
            name: inputEl.name || null,
            placeholder: inputEl.placeholder || null,
            value: inputEl.value || null,
        }
        : null;
    // Media element info
    const isMediaElement = ['IMG', 'VIDEO', 'AUDIO', 'SOURCE'].includes(el.tagName);
    const mediaInfo = isMediaElement
        ? {
            src: imgEl.src || null,
            alt: imgEl.alt || null,
            srcset: imgEl.srcset || null,
        }
        : null;
    // Link element info
    const isLinkElement = el.tagName === 'A';
    const linkInfo = isLinkElement
        ? {
            href: anchorEl.href || null,
            target: anchorEl.target || null,
        }
        : null;
    return {
        tagName: el.tagName.toLowerCase(),
        id: el.id || null,
        classes: getClasses(el),
        textContent: el.textContent?.trim().slice(0, 100) || null,
        selector: generateSelector(el),
        rect: { top: rect.top, left: rect.left, width: rect.width, height: rect.height },
        attributes,
        dataset: htmlEl.dataset ? { ...htmlEl.dataset } : {},
        inlineStyles: getInlineStyles(el),
        computedStyles,
        innerHTML: el.innerHTML.slice(0, 500),
        outerHTML: el.outerHTML.slice(0, 1000),
        ancestors: getAncestors(el),
        children: getChildren(el),
        // Use sourceInfo (aligned with webapp) instead of reactInfo
        sourceInfo: getReactInfo(el),
        inputInfo,
        mediaInfo,
        linkInfo,
    };
}
/**
 * Generate a unique CSS selector for an element.
 */
function generateSelector(el) {
    if (el.id)
        return `#${el.id}`;
    const parts = [];
    let current = el;
    while (current && current !== document.body && current !== document.documentElement) {
        let selector = current.tagName.toLowerCase();
        const parent = current.parentElement;
        if (parent) {
            const sameTagSiblings = Array.from(parent.children).filter((child) => child.tagName === current.tagName);
            const index = sameTagSiblings.indexOf(current) + 1;
            selector += `:nth-of-type(${index})`;
        }
        parts.unshift(selector);
        if (current.parentElement?.id) {
            parts.unshift(`#${current.parentElement.id}`);
            break;
        }
        current = current.parentElement;
    }
    return parts.join(' > ');
}
/**
 * Create and inject the highlight styles.
 */
function createHighlightStyles() {
    const style = document.createElement('style');
    style.setAttribute('data-vibecode-styles', 'true');
    style.textContent = `
		[${HOVERED_ATTR}] {
			outline: 2px solid #0066ff !important;
			outline-offset: 2px !important;
			border-radius: 2px;
		}
		[${CHILD_ATTR}] {
			outline: 1px dashed rgba(0, 102, 255, 0.5) !important;
			outline-offset: 1px !important;
		}
		[${SELECTED_ATTR}] {
			outline: 2px solid rgb(0, 204, 146) !important;
			outline-offset: 2px !important;
			border-radius: 0 2px 2px 2px;
		}
	`;
    document.head.appendChild(style);
    return style;
}
export function VibeSelect() {
    useEffect(() => {
        const handleMessage = (event) => {
            if (event.data?.type === 'vibecode:select:start') {
                startSelection(event.data.requestId);
            }
            else if (event.data?.type === 'vibecode:select:confirm') {
                confirmHandler?.();
            }
            else if (event.data?.type === 'vibecode:select:cancel') {
                activeSession?.();
            }
        };
        window.addEventListener('message', handleMessage);
        return () => window.removeEventListener('message', handleMessage);
    }, []);
    return null;
}
function startSelection(requestId) {
    activeSession?.();
    const selectedElements = new Set();
    const tooltips = new Map();
    let hoveredElement = null;
    // Inject highlight styles
    const styleElement = createHighlightStyles();
    function createTooltip(el) {
        const tooltip = document.createElement('div');
        tooltip.textContent = el.tagName.toLowerCase();
        tooltip.style.cssText = `
			position: fixed;
			pointer-events: none;
			background: rgb(0, 204, 146);
			color: white;
			font-size: 11px;
			font-weight: 600;
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
			padding: 2px 6px;
			border-radius: 3px 3px 0 0;
			z-index: 2147483646;
		`;
        document.body.appendChild(tooltip);
        updateTooltipPosition(el, tooltip);
        return { tooltip };
    }
    function updateTooltipPosition(el, tooltip) {
        const rect = el.getBoundingClientRect();
        tooltip.style.left = `${rect.left - 4}px`;
        tooltip.style.top = `${rect.top - 24}px`;
    }
    function updateAllTooltips() {
        for (const [el, entry] of tooltips.entries()) {
            if (document.contains(el)) {
                updateTooltipPosition(el, entry.tooltip);
            }
        }
    }
    function removeTooltip(entry) {
        entry.tooltip.remove();
    }
    function clearChildHighlights() {
        document.querySelectorAll(`[${CHILD_ATTR}]`).forEach((el) => {
            el.removeAttribute(CHILD_ATTR);
        });
    }
    function showChildHighlights(parent) {
        clearChildHighlights();
        Array.from(parent.children).forEach((child) => {
            child.setAttribute(CHILD_ATTR, '');
        });
    }
    function notifySelection() {
        const elements = Array.from(selectedElements).map(getElementMetadata);
        window.parent.postMessage({
            type: 'vibecode:select:selected',
            requestId,
            elements,
        }, '*');
    }
    const onMouseOver = (e) => {
        const target = e.target;
        if (!target || target === document.body || target === document.documentElement) {
            return;
        }
        // Don't show hover on selected elements
        if (selectedElements.has(target)) {
            if (hoveredElement) {
                hoveredElement.removeAttribute(HOVERED_ATTR);
            }
            clearChildHighlights();
            hoveredElement = null;
            return;
        }
        // Remove hover from previous element
        if (hoveredElement && hoveredElement !== target) {
            hoveredElement.removeAttribute(HOVERED_ATTR);
        }
        hoveredElement = target;
        target.setAttribute(HOVERED_ATTR, '');
        // Show child highlights if element has children
        if (target.children.length > 0) {
            showChildHighlights(target);
        }
        else {
            clearChildHighlights();
        }
    };
    const onMouseOut = (e) => {
        const relatedTarget = e.relatedTarget;
        // Only clear if leaving the document entirely
        if (!relatedTarget || relatedTarget === document.documentElement) {
            if (hoveredElement) {
                hoveredElement.removeAttribute(HOVERED_ATTR);
                hoveredElement = null;
            }
            clearChildHighlights();
        }
    };
    const onClick = (e) => {
        const el = hoveredElement || document.elementFromPoint(e.clientX, e.clientY);
        if (!el || el === document.body || el === document.documentElement) {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        const isMultiSelect = e.metaKey || e.ctrlKey;
        if (isMultiSelect) {
            // Toggle selection
            if (selectedElements.has(el)) {
                el.removeAttribute(SELECTED_ATTR);
                selectedElements.delete(el);
                const entry = tooltips.get(el);
                if (entry) {
                    removeTooltip(entry);
                    tooltips.delete(el);
                }
            }
            else {
                el.setAttribute(SELECTED_ATTR, '');
                selectedElements.add(el);
                tooltips.set(el, createTooltip(el));
            }
        }
        else {
            // Single select - clear others
            for (const selectedEl of selectedElements) {
                selectedEl.removeAttribute(SELECTED_ATTR);
                const entry = tooltips.get(selectedEl);
                if (entry) {
                    removeTooltip(entry);
                }
            }
            selectedElements.clear();
            tooltips.clear();
            el.setAttribute(SELECTED_ATTR, '');
            selectedElements.add(el);
            tooltips.set(el, createTooltip(el));
        }
        // Remove hover highlight from clicked element
        if (hoveredElement) {
            hoveredElement.removeAttribute(HOVERED_ATTR);
            hoveredElement = null;
        }
        clearChildHighlights();
        notifySelection();
    };
    const onConfirm = () => {
        const elements = Array.from(selectedElements).map(getElementMetadata);
        window.parent.postMessage({
            type: 'vibecode:select:result',
            requestId,
            elements,
        }, '*');
        cleanup();
    };
    // MutationObserver to update tooltip positions on DOM changes
    const mutationObserver = new MutationObserver(() => {
        requestAnimationFrame(updateAllTooltips);
    });
    mutationObserver.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true,
        characterData: true,
    });
    const onResize = () => {
        requestAnimationFrame(updateAllTooltips);
    };
    window.addEventListener('resize', onResize);
    const cleanup = () => {
        styleElement.remove();
        if (hoveredElement) {
            hoveredElement.removeAttribute(HOVERED_ATTR);
        }
        clearChildHighlights();
        for (const el of selectedElements) {
            el.removeAttribute(SELECTED_ATTR);
        }
        selectedElements.clear();
        for (const entry of tooltips.values()) {
            removeTooltip(entry);
        }
        tooltips.clear();
        document.removeEventListener('mouseover', onMouseOver, true);
        document.removeEventListener('mouseout', onMouseOut, true);
        document.removeEventListener('click', onClick, true);
        window.removeEventListener('resize', onResize);
        mutationObserver.disconnect();
        activeSession = null;
        confirmHandler = null;
    };
    document.addEventListener('mouseover', onMouseOver, true);
    document.addEventListener('mouseout', onMouseOut, true);
    document.addEventListener('click', onClick, true);
    activeSession = cleanup;
    confirmHandler = onConfirm;
}
//# sourceMappingURL=Select.web.js.map