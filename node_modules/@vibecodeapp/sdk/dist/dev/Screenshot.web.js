/**
 * Web version of Screenshot - listens for screenshot requests from parent iframe
 *
 * On web, this component listens for postMessage requests and captures
 * the current page using html-to-image (Chromium) or html2canvas (Safari/Firefox),
 * then sends the result back.
 * html-to-image is faster than html2canvas, but html2canvas is more reliable on Safari/Firefox.
 * due to the fact that html-to-image uses foreignObjects.
 */
import { useEffect } from 'react';
function isChromium() {
    if (typeof navigator === 'undefined')
        return false;
    const ua = navigator.userAgent;
    return (/Chrome/.test(ua) && !/Edg/.test(ua)) || /Chromium/.test(ua);
}
async function captureScreenshot() {
    const scale = window.devicePixelRatio || 1;
    if (isChromium()) {
        // Use html-to-image for Chromium
        // biome-ignore lint/style/noCommonJs
        const { toBlob } = require('html-to-image');
        const width = document.body.scrollWidth;
        const height = document.body.scrollHeight;
        const blob = await toBlob(document.body, {
            cacheBust: true,
            pixelRatio: scale,
            filter: (node) => node.tagName !== 'NOSCRIPT',
        });
        if (!blob) {
            throw new Error('Failed to create blob from html-to-image');
        }
        const buffer = await blob.arrayBuffer();
        return {
            image: buffer,
            width: width * scale,
            height: height * scale,
        };
    }
    // Use html2canvas for Safari/Firefox
    // biome-ignore lint/style/noCommonJs
    const html2canvas = require('html2canvas').default;
    const canvas = await html2canvas(document.body, {
        useCORS: true,
        allowTaint: true,
        backgroundColor: null,
        scale,
    });
    return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (!blob) {
                reject(new Error('Failed to create blob from canvas'));
                return;
            }
            blob.arrayBuffer().then((buffer) => {
                resolve({
                    image: buffer,
                    width: canvas.width,
                    height: canvas.height,
                });
            });
        }, 'image/png');
    });
}
function postScreenshotToParent(data) {
    try {
        if (typeof window !== 'undefined' &&
            window.parent &&
            window.parent !== window) {
            window.parent.postMessage(data, '*', [data.image]);
        }
    }
    catch {
        // Silently fail
    }
}
export function VibeScreenshot() {
    useEffect(() => {
        const handleMessage = async (event) => {
            if (event.data?.type === 'vibecode:screenshot:request') {
                try {
                    const { image, width, height } = await captureScreenshot();
                    postScreenshotToParent({
                        type: 'vibecode:screenshot:response',
                        requestId: event.data.requestId,
                        image,
                        width,
                        height,
                        timestamp: Date.now(),
                    });
                }
                catch (error) {
                    // Failed to capture screenshot - silently fail
                    console.warn('[Vibecode] Screenshot capture failed:', error);
                }
            }
        };
        window.addEventListener('message', handleMessage);
        return () => window.removeEventListener('message', handleMessage);
    }, []);
    // This component renders nothing
    return null;
}
//# sourceMappingURL=Screenshot.web.js.map