/**
 * HTTP/2 Metro Cache Store
 *
 * A Metro cache store implementation using HTTP/2 with:
 * - Connection pool (default 8 connections) for higher throughput
 * - Multiplexed requests over each connection
 * - Concurrency limiting (configurable max concurrent requests)
 * - Non-blocking writes (fire-and-forget)
 * - Blocking reads
 *
 * Requires an HTTP/2 server - will fail on HTTP/1.1.
 */

const http2 = require('node:http2')
const zlib = require('node:zlib')
const { Buffer } = require('node:buffer')
const pLimit = require('p-limit')

const NULL_BYTE = 0x00
const NULL_BYTE_BUFFER = Buffer.from([NULL_BYTE])

const ZLIB_OPTIONS = {
	level: 9,
}

class HttpStore {
	#origin
	#path
	#timeout
	#sessions = []
	#maxConnections
	#nextSession = 0
	#limit

	/**
	 * @param {Object} options
	 * @param {string} options.endpoint - Full URL to the cache server (e.g., "https://cache.example.com/metro")
	 * @param {number} [options.timeout=10000] - Request timeout in milliseconds
	 * @param {number} [options.maxConnections=8] - Number of HTTP/2 connections in pool
	 * @param {number} [options.maxConcurrent=64] - Max concurrent requests in flight
	 */
	constructor(options) {
		const url = new URL(options.endpoint)
		this.#origin = url.origin
		this.#path = url.pathname.replace(/\/$/, '') // Remove trailing slash
		this.#timeout = options.timeout ?? 10000
		this.#maxConnections = options.maxConnections ?? 8
		this.#limit = pLimit(options.maxConcurrent ?? 64)
	}

	/**
	 * Get an HTTP/2 session from the pool using round-robin.
	 * Lazily creates connections on first use.
	 * Never throws - returns null if connection fails.
	 */
	#getSession() {
		// Round-robin through connections
		const index = this.#nextSession++ % this.#maxConnections

		// Check if we have a valid session at this index
		const existing = this.#sessions[index]
		if (existing && !existing.closed && !existing.destroyed) {
			return existing
		}

		// Create new session for this slot
		try {
			const session = http2.connect(this.#origin)

			session.on('error', (err) => {
				console.warn('[HttpStore] Session error:', err.message)
				if (this.#sessions[index] === session) {
					this.#sessions[index] = null
				}
			})

			session.on('close', () => {
				if (this.#sessions[index] === session) {
					this.#sessions[index] = null
				}
			})

			this.#sessions[index] = session
			return session
		} catch (err) {
			console.warn('[HttpStore] Failed to connect:', err.message)
			return null
		}
	}

	/**
	 * GET - Blocking read from cache.
	 * Returns null on any error (network, timeout, parse) - never throws.
	 * @param {Buffer} key
	 * @returns {Promise<any|null>}
	 */
	async get(key) {
		try {
			return await this.#limit(() => this.#doGet(key))
		} catch (err) {
			console.warn('[HttpStore] Get failed:', err.message)
			return null // Fall back to next cache store (FileStore)
		}
	}

	#doGet(key) {
		return new Promise((resolve, reject) => {
			const session = this.#getSession()
			if (!session) {
				reject(new Error('No session available'))
				return
			}

			const path = `${this.#path}/${key.toString('hex')}`
			const req = session.request({
				':method': 'GET',
				':path': path,
			})

			const timeoutId = setTimeout(() => {
				req.close(http2.constants.NGHTTP2_CANCEL)
				reject(new Error('Request timed out'))
			}, this.#timeout)

			const chunks = []

			req.on('response', (headers) => {
				const status = headers[':status']

				// 404 = cache miss
				if (status === 404) {
					clearTimeout(timeoutId)
					req.close()
					resolve(null)
					return
				}

				// Non-2xx = error
				if (status < 200 || status >= 300) {
					clearTimeout(timeoutId)
					req.close()
					reject(new Error(`HTTP error: ${status}`))
					return
				}
			})

			req.on('data', (chunk) => {
				chunks.push(chunk)
			})

			req.on('end', () => {
				clearTimeout(timeoutId)

				const compressed = Buffer.concat(chunks)
				if (compressed.length === 0) {
					resolve(null)
					return
				}

				// Decompress the response
				zlib.gunzip(compressed, (err, buffer) => {
					if (err) {
						reject(err)
						return
					}

					try {
						// If first byte is NULL_BYTE, it's a raw Buffer
						if (buffer.length > 0 && buffer[0] === NULL_BYTE) {
							resolve(buffer.subarray(1))
						} else {
							resolve(JSON.parse(buffer.toString('utf8')))
						}
					} catch (parseErr) {
						reject(parseErr)
					}
				})
			})

			req.on('error', (err) => {
				clearTimeout(timeoutId)
				reject(err)
			})

			req.end()
		})
	}

	/**
	 * SET - Non-blocking write to cache.
	 * Returns immediately, HTTP request happens in background.
	 * @param {Buffer} key
	 * @param {any} value
	 * @returns {Promise<void>}
	 */
	set(key, value) {
		// Fire and forget - queue the work but return immediately
		this.#limit(() => this.#doSet(key, value)).catch((err) => {
			console.warn('[HttpStore] Background write failed:', err.message)
		})

		return Promise.resolve()
	}

	#doSet(key, value) {
		return new Promise((resolve, reject) => {
			const session = this.#getSession()
			if (!session) {
				reject(new Error('No session available'))
				return
			}

			const path = `${this.#path}/${key.toString('hex')}`

			// Prepare data to compress
			let data
			if (Buffer.isBuffer(value)) {
				// Prepend NULL_BYTE marker for Buffer values
				data = Buffer.concat([NULL_BYTE_BUFFER, value])
			} else {
				data = Buffer.from(JSON.stringify(value) ?? 'null', 'utf8')
			}

			// Compress the data
			zlib.gzip(data, ZLIB_OPTIONS, (err, compressed) => {
				if (err) {
					reject(err)
					return
				}

				const req = session.request({
					':method': 'PUT',
					':path': path,
					'content-type': 'application/octet-stream',
					'content-length': compressed.length,
				})

				const timeoutId = setTimeout(() => {
					req.close(http2.constants.NGHTTP2_CANCEL)
					reject(new Error('Request timed out'))
				}, this.#timeout)

				req.on('response', (headers) => {
					const status = headers[':status']

					clearTimeout(timeoutId)

					if (status >= 200 && status < 300) {
						resolve()
					} else {
						reject(new Error(`HTTP error: ${status}`))
					}
				})

				req.on('error', (err) => {
					clearTimeout(timeoutId)
					reject(err)
				})

				req.write(compressed)
				req.end()
			})
		})
	}

	/**
	 * CLEAR - Not implemented.
	 */
	clear() {
		// No-op - Metro's HTTP cache protocol doesn't define a clear operation
	}
}

module.exports = { HttpStore }
