const path = require('node:path')
const os = require('node:os')
const { FileStore } = require('metro-cache')
const { HttpStore } = require('./metro-http-store.cjs')

/**
 * Metro configuration helper for Vibecode
 * Provides web polyfills and HTTP cache store for remote caching.
 */

const distPath = path.resolve(__dirname, '../dist/')

/**
 * Create cache stores array for Metro config.
 *
 * @param {Object} options
 * @param {string} [options.cacheDir] - Local cache directory (default: ~/.metro-cache)
 * @param {string} [options.httpEndpoint] - HTTP/2 cache server endpoint (optional)
 * @param {number} [options.httpTimeout=30000] - HTTP cache timeout in ms
 * @param {number} [options.httpMaxConnections=64] - Max HTTP/2 connections
 * @param {number} [options.httpMaxConcurrent=256] - Max concurrent HTTP requests
 * @returns {Array} Array of cache store instances
 */
function createCacheStores(options = {}) {
	const cacheDir =
		options.cacheDir ||
		process.env.METRO_CACHE_DIR ||
		path.join(os.homedir(), '.metro-cache')

	const httpEndpoint =
		options.httpEndpoint || process.env.METRO_CACHE_HTTP_ENDPOINT

	const stores = [new FileStore({ root: cacheDir })]

	if (httpEndpoint) {
		stores.push(
			new HttpStore({
				endpoint: httpEndpoint,
				timeout: options.httpTimeout ?? 30000,
				maxConnections: options.httpMaxConnections ?? 64,
				maxConcurrent: options.httpMaxConcurrent ?? 256,
			}),
		)
	}

	return stores
}

/**
 * Wrap a Metro config with Vibecode enhancements.
 *
 * Features:
 * - Web polyfills for expo-haptics, expo-secure-store, react-native-maps, etc.
 * - Optional HTTP/2 remote cache store
 * - Configurable cache settings
 *
 * @param {Object} config - Base Metro config
 * @param {Object} [options]
 * @param {boolean} [options.enableCache=true] - Enable cache configuration
 * @param {string} [options.cacheDir] - Local cache directory
 * @param {string} [options.cacheVersion] - Cache version string
 * @param {string} [options.httpEndpoint] - HTTP/2 cache server endpoint
 * @param {number} [options.httpTimeout] - HTTP cache timeout
 * @param {number} [options.httpMaxConnections] - Max HTTP/2 connections
 * @param {number} [options.httpMaxConcurrent] - Max concurrent requests
 * @returns {Object} Enhanced Metro config
 */
// Path to the fetch polyfill that auto-initializes the proxy
const fetchPolyfillPath = path.resolve(distPath, 'polyfills/fetch.web.js')

function withVibecodeMetro(config, options = {}) {
	const originalResolveRequest = config.resolver?.resolveRequest
	const originalGetModulesRunBeforeMainModule =
		config.serializer?.getModulesRunBeforeMainModule
	const enableCache = options.enableCache !== false

	const result = {
		...config,
		serializer: {
			...config.serializer,
			// Inject the fetch polyfill to run before the main module on web
			getModulesRunBeforeMainModule: (entryFilePath) => {
				const originalModules = originalGetModulesRunBeforeMainModule
					? originalGetModulesRunBeforeMainModule(entryFilePath)
					: []
				// Add our fetch polyfill to run before the app starts
				return [...originalModules, fetchPolyfillPath]
			},
		},
		transformer: {
			...config.transformer,
			babelTransformerPath: require.resolve('./transformer.cjs'),
		},
		resolver: {
			...config.resolver,
			extraNodeModules: {
				assert: require.resolve('assert'),
				...config.resolver?.extraNodeModules,
			},
			resolveRequest: (context, moduleName, platform) => {
				// Redirect expo-haptics to our web polyfill on web platform
				if (moduleName === 'expo-haptics' && platform === 'web') {
					return {
						filePath: path.resolve(distPath, 'polyfills/haptics.web.js'),
						type: 'sourceFile',
					}
				}

				if (moduleName === 'expo-secure-store' && platform === 'web') {
					return {
						filePath: path.resolve(distPath, 'polyfills/secure-store.web.js'),
						type: 'sourceFile',
					}
				}

				if (moduleName === 'react-native-maps' && platform === 'web') {
					return {
						filePath: path.resolve(distPath, 'polyfills/maps.web.js'),
						type: 'sourceFile',
					}
				}

				if (
					moduleName === 'react-native-web/dist/exports/RefreshControl' &&
					platform === 'web'
				) {
					return {
						filePath: path.resolve(
							distPath,
							'polyfills/refresh-control-component.js',
						),
						type: 'sourceFile',
					}
				}

				if (
					moduleName === 'react-native-web/dist/exports/Alert' &&
					platform === 'web'
				) {
					return {
						filePath: path.resolve(distPath, 'polyfills/alert.web.js'),
						type: 'sourceFile',
					}
				}

				// Override expo/fetch on web to use our proxy-enabled fetch
				if (moduleName === 'expo/fetch' && platform === 'web') {
					return {
						filePath: path.resolve(distPath, 'polyfills/fetch.web.js'),
						type: 'sourceFile',
					}
				}

				// Override expo-status-bar on web to post status bar color to parent iframe
				if (moduleName === 'expo-status-bar' && platform === 'web') {
					return {
						filePath: path.resolve(distPath, 'dev/StatusBar.web.js'),
						type: 'sourceFile',
					}
				}

				if (originalResolveRequest) {
					return originalResolveRequest(context, moduleName, platform)
				}

				return context.resolveRequest(context, moduleName, platform)
			},
		},
	}

	// Configure caching if enabled
	if (enableCache) {
		result.cacheStores = createCacheStores({
			cacheDir: options.cacheDir,
			httpEndpoint: options.httpEndpoint,
			httpTimeout: options.httpTimeout,
			httpMaxConnections: options.httpMaxConnections,
			httpMaxConcurrent: options.httpMaxConcurrent,
		})

		result.cacheVersion =
			options.cacheVersion || process.env.METRO_CACHE_VERSION || '1'
	}

	return result
}

module.exports = { withVibecodeMetro }
