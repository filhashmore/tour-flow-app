"use strict";

/* eslint-disable react-hooks/rules-of-hooks */
import { useCallback, useMemo } from 'react';
import { useAnimatedReaction } from 'react-native-reanimated';
import { useDebugContext } from '../../../debug';
import { isValidVector } from '../../../utils';
import { useCommonValuesContext } from '../CommonValuesProvider';
const DEBUG_COLORS = {
  backgroundColor: '#1111ef',
  borderColor: '#00007e'
};
const DEBUG_RECT_KEYS = ['bottom', 'left', 'right', 'top'];
export default function useDebugBoundingBox(isAbsolute = false) {
  if (!__DEV__) {
    return undefined;
  }
  const {
    activeItemKey
  } = useCommonValuesContext();
  const debugContext = useDebugContext();
  const debugRects = debugContext?.useDebugRects(DEBUG_RECT_KEYS);
  const updateDebugRect = useCallback((key, from, to, colors) => {
    'worklet';

    if (!isValidVector(from) || !isValidVector(to)) {
      debugRects?.[key]?.hide();
    } else {
      debugRects?.[key]?.set({
        ...(colors ?? DEBUG_COLORS),
        from,
        isAbsolute,
        to
      });
    }
  }, [debugRects, isAbsolute]);
  const debugBox = useMemo(() => ({
    ...Object.fromEntries(DEBUG_RECT_KEYS.map(key => [key, {
      hide: () => {
        'worklet';

        debugRects?.[key]?.hide();
      },
      update: (from, to, colors) => {
        'worklet';

        updateDebugRect(key, from, to, colors);
      }
    }])),
    hide: () => {
      'worklet';

      DEBUG_RECT_KEYS.forEach(key => debugRects?.[key]?.hide());
    }
  }), [updateDebugRect, debugRects]);
  useAnimatedReaction(() => activeItemKey.value, () => {
    if (debugRects && activeItemKey.value === null) {
      Object.values(debugRects).forEach(rect => rect.hide());
    }
  });
  return debugRects && debugBox;
}
//# sourceMappingURL=useDebugBoundingBox.js.map