
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <folly/dynamic.h>
#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <react/renderer/graphics/Color.h>
#include <vector>

namespace facebook::react {

struct EnrichedTextInputViewHtmlStyleH1Struct {
  Float fontSize{0.0};
  bool bold{false};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const EnrichedTextInputViewHtmlStyleH1Struct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["fontSize"] = fontSize;
    result["bold"] = bold;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, EnrichedTextInputViewHtmlStyleH1Struct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue(context, tmp_fontSize->second, result.fontSize);
  }
  auto tmp_bold = map.find("bold");
  if (tmp_bold != map.end()) {
    fromRawValue(context, tmp_bold->second, result.bold);
  }
}

static inline std::string toString(const EnrichedTextInputViewHtmlStyleH1Struct &value) {
  return "[Object EnrichedTextInputViewHtmlStyleH1Struct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleH1Struct &value) {
  return value.toDynamic();
}
#endif

struct EnrichedTextInputViewHtmlStyleH2Struct {
  Float fontSize{0.0};
  bool bold{false};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const EnrichedTextInputViewHtmlStyleH2Struct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["fontSize"] = fontSize;
    result["bold"] = bold;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, EnrichedTextInputViewHtmlStyleH2Struct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue(context, tmp_fontSize->second, result.fontSize);
  }
  auto tmp_bold = map.find("bold");
  if (tmp_bold != map.end()) {
    fromRawValue(context, tmp_bold->second, result.bold);
  }
}

static inline std::string toString(const EnrichedTextInputViewHtmlStyleH2Struct &value) {
  return "[Object EnrichedTextInputViewHtmlStyleH2Struct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleH2Struct &value) {
  return value.toDynamic();
}
#endif

struct EnrichedTextInputViewHtmlStyleH3Struct {
  Float fontSize{0.0};
  bool bold{false};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const EnrichedTextInputViewHtmlStyleH3Struct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["fontSize"] = fontSize;
    result["bold"] = bold;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, EnrichedTextInputViewHtmlStyleH3Struct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue(context, tmp_fontSize->second, result.fontSize);
  }
  auto tmp_bold = map.find("bold");
  if (tmp_bold != map.end()) {
    fromRawValue(context, tmp_bold->second, result.bold);
  }
}

static inline std::string toString(const EnrichedTextInputViewHtmlStyleH3Struct &value) {
  return "[Object EnrichedTextInputViewHtmlStyleH3Struct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleH3Struct &value) {
  return value.toDynamic();
}
#endif

struct EnrichedTextInputViewHtmlStyleBlockquoteStruct {
  SharedColor borderColor{};
  Float borderWidth{0.0};
  Float gapWidth{0.0};
  SharedColor color{};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const EnrichedTextInputViewHtmlStyleBlockquoteStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["borderColor"] = ::facebook::react::toDynamic(borderColor);
    result["borderWidth"] = borderWidth;
    result["gapWidth"] = gapWidth;
    result["color"] = ::facebook::react::toDynamic(color);
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, EnrichedTextInputViewHtmlStyleBlockquoteStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_borderColor = map.find("borderColor");
  if (tmp_borderColor != map.end()) {
    fromRawValue(context, tmp_borderColor->second, result.borderColor);
  }
  auto tmp_borderWidth = map.find("borderWidth");
  if (tmp_borderWidth != map.end()) {
    fromRawValue(context, tmp_borderWidth->second, result.borderWidth);
  }
  auto tmp_gapWidth = map.find("gapWidth");
  if (tmp_gapWidth != map.end()) {
    fromRawValue(context, tmp_gapWidth->second, result.gapWidth);
  }
  auto tmp_color = map.find("color");
  if (tmp_color != map.end()) {
    fromRawValue(context, tmp_color->second, result.color);
  }
}

static inline std::string toString(const EnrichedTextInputViewHtmlStyleBlockquoteStruct &value) {
  return "[Object EnrichedTextInputViewHtmlStyleBlockquoteStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleBlockquoteStruct &value) {
  return value.toDynamic();
}
#endif

struct EnrichedTextInputViewHtmlStyleCodeblockStruct {
  SharedColor color{};
  Float borderRadius{0.0};
  SharedColor backgroundColor{};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const EnrichedTextInputViewHtmlStyleCodeblockStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["color"] = ::facebook::react::toDynamic(color);
    result["borderRadius"] = borderRadius;
    result["backgroundColor"] = ::facebook::react::toDynamic(backgroundColor);
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, EnrichedTextInputViewHtmlStyleCodeblockStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_color = map.find("color");
  if (tmp_color != map.end()) {
    fromRawValue(context, tmp_color->second, result.color);
  }
  auto tmp_borderRadius = map.find("borderRadius");
  if (tmp_borderRadius != map.end()) {
    fromRawValue(context, tmp_borderRadius->second, result.borderRadius);
  }
  auto tmp_backgroundColor = map.find("backgroundColor");
  if (tmp_backgroundColor != map.end()) {
    fromRawValue(context, tmp_backgroundColor->second, result.backgroundColor);
  }
}

static inline std::string toString(const EnrichedTextInputViewHtmlStyleCodeblockStruct &value) {
  return "[Object EnrichedTextInputViewHtmlStyleCodeblockStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleCodeblockStruct &value) {
  return value.toDynamic();
}
#endif

struct EnrichedTextInputViewHtmlStyleCodeStruct {
  SharedColor color{};
  SharedColor backgroundColor{};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const EnrichedTextInputViewHtmlStyleCodeStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["color"] = ::facebook::react::toDynamic(color);
    result["backgroundColor"] = ::facebook::react::toDynamic(backgroundColor);
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, EnrichedTextInputViewHtmlStyleCodeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_color = map.find("color");
  if (tmp_color != map.end()) {
    fromRawValue(context, tmp_color->second, result.color);
  }
  auto tmp_backgroundColor = map.find("backgroundColor");
  if (tmp_backgroundColor != map.end()) {
    fromRawValue(context, tmp_backgroundColor->second, result.backgroundColor);
  }
}

static inline std::string toString(const EnrichedTextInputViewHtmlStyleCodeStruct &value) {
  return "[Object EnrichedTextInputViewHtmlStyleCodeStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleCodeStruct &value) {
  return value.toDynamic();
}
#endif

struct EnrichedTextInputViewHtmlStyleAStruct {
  SharedColor color{};
  std::string textDecorationLine{};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const EnrichedTextInputViewHtmlStyleAStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["color"] = ::facebook::react::toDynamic(color);
    result["textDecorationLine"] = textDecorationLine;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, EnrichedTextInputViewHtmlStyleAStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_color = map.find("color");
  if (tmp_color != map.end()) {
    fromRawValue(context, tmp_color->second, result.color);
  }
  auto tmp_textDecorationLine = map.find("textDecorationLine");
  if (tmp_textDecorationLine != map.end()) {
    fromRawValue(context, tmp_textDecorationLine->second, result.textDecorationLine);
  }
}

static inline std::string toString(const EnrichedTextInputViewHtmlStyleAStruct &value) {
  return "[Object EnrichedTextInputViewHtmlStyleAStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleAStruct &value) {
  return value.toDynamic();
}
#endif

struct EnrichedTextInputViewHtmlStyleImgStruct {
  Float width{0.0};
  Float height{0.0};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const EnrichedTextInputViewHtmlStyleImgStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["width"] = width;
    result["height"] = height;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, EnrichedTextInputViewHtmlStyleImgStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_width = map.find("width");
  if (tmp_width != map.end()) {
    fromRawValue(context, tmp_width->second, result.width);
  }
  auto tmp_height = map.find("height");
  if (tmp_height != map.end()) {
    fromRawValue(context, tmp_height->second, result.height);
  }
}

static inline std::string toString(const EnrichedTextInputViewHtmlStyleImgStruct &value) {
  return "[Object EnrichedTextInputViewHtmlStyleImgStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleImgStruct &value) {
  return value.toDynamic();
}
#endif

struct EnrichedTextInputViewHtmlStyleOlStruct {
  Float gapWidth{0.0};
  Float marginLeft{0.0};
  std::string markerFontWeight{};
  SharedColor markerColor{};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const EnrichedTextInputViewHtmlStyleOlStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["gapWidth"] = gapWidth;
    result["marginLeft"] = marginLeft;
    result["markerFontWeight"] = markerFontWeight;
    result["markerColor"] = ::facebook::react::toDynamic(markerColor);
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, EnrichedTextInputViewHtmlStyleOlStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_gapWidth = map.find("gapWidth");
  if (tmp_gapWidth != map.end()) {
    fromRawValue(context, tmp_gapWidth->second, result.gapWidth);
  }
  auto tmp_marginLeft = map.find("marginLeft");
  if (tmp_marginLeft != map.end()) {
    fromRawValue(context, tmp_marginLeft->second, result.marginLeft);
  }
  auto tmp_markerFontWeight = map.find("markerFontWeight");
  if (tmp_markerFontWeight != map.end()) {
    fromRawValue(context, tmp_markerFontWeight->second, result.markerFontWeight);
  }
  auto tmp_markerColor = map.find("markerColor");
  if (tmp_markerColor != map.end()) {
    fromRawValue(context, tmp_markerColor->second, result.markerColor);
  }
}

static inline std::string toString(const EnrichedTextInputViewHtmlStyleOlStruct &value) {
  return "[Object EnrichedTextInputViewHtmlStyleOlStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleOlStruct &value) {
  return value.toDynamic();
}
#endif

struct EnrichedTextInputViewHtmlStyleUlStruct {
  SharedColor bulletColor{};
  Float bulletSize{0.0};
  Float marginLeft{0.0};
  Float gapWidth{0.0};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const EnrichedTextInputViewHtmlStyleUlStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["bulletColor"] = ::facebook::react::toDynamic(bulletColor);
    result["bulletSize"] = bulletSize;
    result["marginLeft"] = marginLeft;
    result["gapWidth"] = gapWidth;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, EnrichedTextInputViewHtmlStyleUlStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_bulletColor = map.find("bulletColor");
  if (tmp_bulletColor != map.end()) {
    fromRawValue(context, tmp_bulletColor->second, result.bulletColor);
  }
  auto tmp_bulletSize = map.find("bulletSize");
  if (tmp_bulletSize != map.end()) {
    fromRawValue(context, tmp_bulletSize->second, result.bulletSize);
  }
  auto tmp_marginLeft = map.find("marginLeft");
  if (tmp_marginLeft != map.end()) {
    fromRawValue(context, tmp_marginLeft->second, result.marginLeft);
  }
  auto tmp_gapWidth = map.find("gapWidth");
  if (tmp_gapWidth != map.end()) {
    fromRawValue(context, tmp_gapWidth->second, result.gapWidth);
  }
}

static inline std::string toString(const EnrichedTextInputViewHtmlStyleUlStruct &value) {
  return "[Object EnrichedTextInputViewHtmlStyleUlStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleUlStruct &value) {
  return value.toDynamic();
}
#endif

struct EnrichedTextInputViewHtmlStyleStruct {
  EnrichedTextInputViewHtmlStyleH1Struct h1{};
  EnrichedTextInputViewHtmlStyleH2Struct h2{};
  EnrichedTextInputViewHtmlStyleH3Struct h3{};
  EnrichedTextInputViewHtmlStyleBlockquoteStruct blockquote{};
  EnrichedTextInputViewHtmlStyleCodeblockStruct codeblock{};
  EnrichedTextInputViewHtmlStyleCodeStruct code{};
  EnrichedTextInputViewHtmlStyleAStruct a{};
  folly::dynamic mention{};
  EnrichedTextInputViewHtmlStyleImgStruct img{};
  EnrichedTextInputViewHtmlStyleOlStruct ol{};
  EnrichedTextInputViewHtmlStyleUlStruct ul{};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const EnrichedTextInputViewHtmlStyleStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["h1"] = ::facebook::react::toDynamic(h1);
    result["h2"] = ::facebook::react::toDynamic(h2);
    result["h3"] = ::facebook::react::toDynamic(h3);
    result["blockquote"] = ::facebook::react::toDynamic(blockquote);
    result["codeblock"] = ::facebook::react::toDynamic(codeblock);
    result["code"] = ::facebook::react::toDynamic(code);
    result["a"] = ::facebook::react::toDynamic(a);
    result["mention"] = mention;
    result["img"] = ::facebook::react::toDynamic(img);
    result["ol"] = ::facebook::react::toDynamic(ol);
    result["ul"] = ::facebook::react::toDynamic(ul);
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, EnrichedTextInputViewHtmlStyleStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_h1 = map.find("h1");
  if (tmp_h1 != map.end()) {
    fromRawValue(context, tmp_h1->second, result.h1);
  }
  auto tmp_h2 = map.find("h2");
  if (tmp_h2 != map.end()) {
    fromRawValue(context, tmp_h2->second, result.h2);
  }
  auto tmp_h3 = map.find("h3");
  if (tmp_h3 != map.end()) {
    fromRawValue(context, tmp_h3->second, result.h3);
  }
  auto tmp_blockquote = map.find("blockquote");
  if (tmp_blockquote != map.end()) {
    fromRawValue(context, tmp_blockquote->second, result.blockquote);
  }
  auto tmp_codeblock = map.find("codeblock");
  if (tmp_codeblock != map.end()) {
    fromRawValue(context, tmp_codeblock->second, result.codeblock);
  }
  auto tmp_code = map.find("code");
  if (tmp_code != map.end()) {
    fromRawValue(context, tmp_code->second, result.code);
  }
  auto tmp_a = map.find("a");
  if (tmp_a != map.end()) {
    fromRawValue(context, tmp_a->second, result.a);
  }
  auto tmp_mention = map.find("mention");
  if (tmp_mention != map.end()) {
    fromRawValue(context, tmp_mention->second, result.mention);
  }
  auto tmp_img = map.find("img");
  if (tmp_img != map.end()) {
    fromRawValue(context, tmp_img->second, result.img);
  }
  auto tmp_ol = map.find("ol");
  if (tmp_ol != map.end()) {
    fromRawValue(context, tmp_ol->second, result.ol);
  }
  auto tmp_ul = map.find("ul");
  if (tmp_ul != map.end()) {
    fromRawValue(context, tmp_ul->second, result.ul);
  }
}

static inline std::string toString(const EnrichedTextInputViewHtmlStyleStruct &value) {
  return "[Object EnrichedTextInputViewHtmlStyleStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const EnrichedTextInputViewHtmlStyleStruct &value) {
  return value.toDynamic();
}
#endif
class EnrichedTextInputViewProps final : public ViewProps {
 public:
  EnrichedTextInputViewProps() = default;
  EnrichedTextInputViewProps(const PropsParserContext& context, const EnrichedTextInputViewProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  bool autoFocus{false};
  bool editable{false};
  std::string defaultValue{};
  std::string placeholder{};
  SharedColor placeholderTextColor{};
  std::vector<std::string> mentionIndicators{};
  SharedColor cursorColor{};
  SharedColor selectionColor{};
  std::string autoCapitalize{};
  EnrichedTextInputViewHtmlStyleStruct htmlStyle{};
  bool scrollEnabled{false};
  SharedColor color{};
  Float fontSize{0.0};
  std::string fontFamily{};
  std::string fontWeight{};
  std::string fontStyle{};
  bool isOnChangeHtmlSet{false};
  bool androidExperimentalSynchronousEvents{false};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif
};

} // namespace facebook::react
